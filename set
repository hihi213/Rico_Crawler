from __future__ import annotations

import logging
import subprocess
import sys
from pathlib import Path
from typing import Any


def venv_python_candidate() -> Path:
    root = Path(__file__).resolve().parent
    if (root / "venv" / "bin" / "python").exists():
        return root / "venv" / "bin" / "python"
    if (root / "venv" / "Scripts" / "python.exe").exists():
        return root / "venv" / "Scripts" / "python.exe"
    return Path()


try:
    import yaml
except ModuleNotFoundError:  # pragma: no cover
    candidate = venv_python_candidate()
    if candidate and candidate != Path(sys.executable):
        subprocess.run([str(candidate), str(Path(__file__).resolve()), *sys.argv[1:]], check=False)
        sys.exit(0)
    print("필수 패키지(pyyaml)가 없습니다. 먼저 `python install`을 실행하세요.")
    sys.exit(1)


def usage(logger: logging.Logger) -> None:
    logger.info("사용법:")
    logger.info("  python set <KEY> <VALUE>     # config.yaml 변경")
    logger.info("  python set keys              # 설정 키 목록 출력")
    logger.info("예시:")
    logger.info("  python set crawl.max_pages 10")
    logger.info("  python set keys")


def parse_value(value: str) -> Any:
    return yaml.safe_load(value)


def key_exists(data: dict[str, Any], key_path: str) -> bool:
    keys = key_path.split(".")
    current: Any = data
    for key in keys:
        if not isinstance(current, dict) or key not in current:
            return False
        current = current[key]
    return True


def set_config_value(config_path: Path, key_path: str, value: Any) -> None:
    with config_path.open("r", encoding="utf-8") as f:
        data = yaml.safe_load(f) or {}

    keys = key_path.split(".")
    current = data
    for key in keys[:-1]:
        if key not in current or not isinstance(current[key], dict):
            current[key] = {}
        current = current[key]
    current[keys[-1]] = value

    with config_path.open("w", encoding="utf-8") as f:
        yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)


def collect_keys(data: dict[str, Any], prefix: str = "") -> list[str]:
    keys: list[str] = []
    for k, v in data.items():
        path = f"{prefix}{k}" if not prefix else f"{prefix}.{k}"
        if isinstance(v, dict):
            keys.extend(collect_keys(v, path))
        else:
            keys.append(path)
    return keys


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    logger = logging.getLogger("set")
    argv = sys.argv[1:]

    if not argv:
        usage(logger)
        sys.exit(1)

    config_path = Path(__file__).resolve().parent / "config.yaml"

    if argv[0] in ("keys", "set-keys") and len(argv) == 1:
        with config_path.open("r", encoding="utf-8") as f:
            data = yaml.safe_load(f) or {}
        for key in collect_keys(data):
            logger.info(key)
        return

    if len(argv) == 2:
        key_path, raw_value = argv
        with config_path.open("r", encoding="utf-8") as f:
            data = yaml.safe_load(f) or {}
        if not key_exists(data, key_path):
            logger.warning("알 수 없는 키입니다: %s", key_path)
            logger.info("가능한 키 목록은 `python set keys`로 확인하세요.")
            sys.exit(2)
        value = parse_value(raw_value)
        set_config_value(config_path, key_path, value)
        logger.info("config.yaml 업데이트 완료: %s", key_path)
        return

    usage(logger)
    sys.exit(1)


if __name__ == "__main__":
    main()
